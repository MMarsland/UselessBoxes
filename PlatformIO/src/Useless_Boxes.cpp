/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/2d0c6d34-797a-4076-ac97-e148be234e6e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String active_box;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include <Arduino.h>
#include "Useless_Boxes.h"
#include "thingProperties.h"

// ===== Pin assignments =====
const int IN1 = 2;           // Motor direction A
const int IN2 = 3;           // Motor direction B
const int EN1 = 4;           // Motor enable (PWM capable)
const int RGB_R = 5;         // LED Red
const int RGB_G = 6;         // LED Green
const int RGB_B = 7;         // LED Blue
const int SWITCH_PIN = 8;    // SPDT switch
const int LIMIT_PIN = 9;     // Limit Switch
const int BUTTON_PIN = 10;   // Settings button
const int BUZZER_PIN = 11;   // Buzzer

// === SETTINGS BUTTON HANDLER ======================================
// Adjustable thresholds
const unsigned long LONG_PRESS_TIME = 1000;   // ms
const unsigned long DEBOUNCE_TIME   = 50;     // ms

// === MENU SYSTEM VARIABLES ===
int menuIndex = 0;
const int totalMenus = 3;
bool inSubMenu = false;

// SETTINGS
bool motorAutoMode = false;
int led_brightness_percentage = 100; // 0–100

// Variables for button tracking
bool settingsButtonState = HIGH;
bool lastSettingsButtonState = HIGH;

unsigned long pressedTime = 0;
unsigned long releasedTime = 0;

bool longPressActive = false;
unsigned long lastDebounceTime = 0;

int shortPressCount = 0;
int longPressCount  = 0;

// Keep track of previous press counts
int lastShortPressCount = 0;
int lastLongPressCount  = 0;

// Inactivity timeout
const unsigned long MENU_TIMEOUT_MS = 5000;
unsigned long lastInteractionTime = 0;  // resets every button press

bool led_on = false;

// === MOTOR CONTROL HANDLER ========================================
unsigned long lastMotorUpdate = 0;
const unsigned long MOTOR_UPDATE_INTERVAL = 50; // ms

bool switch_forward = true;
bool button_pressed = false;
bool motor_forward = true;
bool motor_enabled = true;

// ==================================================================
// === SETUP ========================================================
// ==================================================================
void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(200); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();



  // Set the Board LED as outputs
  pinMode(LED_RED, OUTPUT);
  pinMode(LED_BLUE, OUTPUT);
  pinMode(LED_GREEN, OUTPUT);

  // Set the RGB LED as outputs
  pinMode(RGB_R, OUTPUT);
  pinMode(RGB_B, OUTPUT);
  pinMode(RGB_G, OUTPUT);
  // Turn LED fully off at startup
  setRGB(0, 0, 0)

  // Set the Buzzer Pin as an output
  pinMode(BUZZER_PIN, OUTPUT);

  // Motor pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(EN1, OUTPUT);

  // Inputs with internal pull-ups
  pinMode(SWITCH_PIN, INPUT_PULLUP);
  pinMode(LIMIT_PIN, INPUT_PULLUP);

  // Set starting state
  switch_forward = digitalRead(SWITCH_PIN);
  button_pressed = digitalRead(LIMIT_PIN); 
  modifyMotorState(switch_forward, button_pressed);

  // Settings button
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  // Reflect starting state
  onActiveBoxChange();
  Serial.println("System Initialized.");
}

// ==================================================================
// === MAIN LOOP ====================================================
// ==================================================================
void loop() {
    ArduinoCloud.update();
    handleSettingsButton();   // independent from motor
  
    // Run motor control every 50 ms (non-blocking)
    if (millis() - lastMotorUpdate >= MOTOR_UPDATE_INTERVAL) {
      lastMotorUpdate = millis();
      handleMotorControl();
    }

    updateAnimations();   // RGB effects (rainbow, pulse, etc)
    updateBuzzerAlarm();  // Looping buzzer patterns
    handleSerialMenu();
}

// ==================================================================
// === SETTINGS BUTTON HANDLER ======================================
// ==================================================================
void handleSettingsButton() {
  bool reading = digitalRead(BUTTON_PIN);

  // Debounce
  if (reading != lastSettingsButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > DEBOUNCE_TIME) {
    if (reading != settingsButtonState) {
      settingsButtonState = reading;

      // Just pressed
      if (settingsButtonState == LOW) {
        pressedTime = millis();
        longPressActive = false;
      }

      // Just released
      else {
        unsigned long pressDuration = millis() - pressedTime;
        if (pressDuration < LONG_PRESS_TIME && !longPressActive) {
          shortPressCount++;
          Serial.print("Short press #");
          Serial.println(shortPressCount);
        }
      }
    }
  }

  // Detect long press
  if (settingsButtonState == LOW && !longPressActive && 
      (millis() - pressedTime > LONG_PRESS_TIME)) {
    longPressActive = true;
    longPressCount++;
    Serial.print("Long press #");
    Serial.println(longPressCount);
  }

  lastSettingsButtonState = reading;
}


// ==================================================================
// === SETTINGS MENU (Refactored / Data-Driven) ======================
// ==================================================================

/*
 This system is fully modular:
  - To add a new menu, create:
      showX(), adjustX(), enterX()
  - Then add one line inside the menuItems[] table below.

 Core logic stays unchanged forever.
*/

// Forward declarations for menu handler functions



// =============================================================
// MENU STRUCTURE
// =============================================================

struct MenuItem {
  const char* name;
  void (*onEnter)();    // Called on long press when entering submenu
  void (*onAdjust)();   // Called on short press while inside submenu
  void (*onShow)();     // (Optional) show preview when scrolling menus
};


// =============================================================
// MENU TABLE — ADD NEW MENUS HERE
// =============================================================

MenuItem menuItems[] = {
  { "Motor Mode",      enterMotorMode,    adjustMotorMode,    showMotorMode },
  { "LED Brightness",  enterBrightness,   adjustBrightness,   showBrightness },
  { "Active Box",      enterActiveBox,    adjustActiveBox,    showActiveBox },
  { "RGB LED",         enterRGB,          adjustRGB,          showRGB },
  { "Buzzer Pattern",  enterBuzzer,       adjustBuzzer,       showBuzzer }
};

int totalMenus = sizeof(menuItems) / sizeof(MenuItem);


// =============================================================
//     MAIN MENU HANDLER (Button-driven navigation)
// =============================================================

void handleSerialMenu() {
  unsigned long now = millis();

  // Timeout → return to main screen
  if ((now - lastInteractionTime) > MENU_TIMEOUT_MS && (menuIndex != 0 || inSubMenu)) {
    Serial.println("\n⏱️ Menu timed out — returning to main screen.\n");
    menuIndex = 0;
    inSubMenu = false;
    showMenu();
  }

  // Short press: next menu item OR adjust submenu value
  if (shortPressCount > lastShortPressCount) {
    lastShortPressCount = shortPressCount;
    lastInteractionTime = now;

    if (!inSubMenu) {
      menuIndex = (menuIndex + 1) % totalMenus;
      showMenu();
    } else {
      menuItems[menuIndex].onAdjust();
    }
  }

  // Long press: enter submenu OR confirm/save
  if (longPressCount > lastLongPressCount) {
    lastLongPressCount = longPressCount;
    lastInteractionTime = now;

    if (!inSubMenu) {
      inSubMenu = true;
      Serial.print("⚙️ Editing ");
      Serial.println(menuItems[menuIndex].name);
      menuItems[menuIndex].onEnter();
    } else {
      inSubMenu = false;
      Serial.println("✅ Saved and returned to main menu.");
      showMenu();
    }
  }
}


// =============================================================
//    MENU DISPLAY
// =============================================================
void showMenu() {
  Serial.println();
  Serial.print("> Setting ");
  Serial.print(menuIndex + 1);
  Serial.print(": ");
  Serial.println(menuItems[menuIndex].name);

  // Optional: live preview under each menu
  if (menuItems[menuIndex].onShow) {
    menuItems[menuIndex].onShow();
  }
}


// ==================================================================
// === INDIVIDUAL MENU HANDLERS ======================================
// ==================================================================

// ---------------- MOTOR MODE ----------------
void showMotorMode() {
  Serial.print("Motor Mode: ");
  Serial.println(motorAutoMode ? "AUTO" : "MANUAL");
}
void adjustMotorMode() {
  motorAutoMode = !motorAutoMode;
  showMotorMode();
}
void enterMotorMode() {
  showMotorMode();
}


// ---------------- LED BRIGHTNESS ----------------
void showBrightness() {
  Serial.print("LED Brightness: ");
  Serial.print(led_brightness_percentage);
  Serial.println("%");
}
void adjustBrightness() {
  led_brightness_percentage += 10;
  if (led_brightness_percentage > 100) led_brightness_percentage = 0;

  adjustLED();
  showBrightness();
}
void enterBrightness() {
  showBrightness();
}


// ---------------- ACTIVE BOX ----------------
void showActiveBox() {
  Serial.print("Active Box: ");
  Serial.println(active_box);
}
void adjustActiveBox() {
  setActiveBox(active_box == "TREVOR" ? "MICHAEL" : "TREVOR");
  showActiveBox();
}
void enterActiveBox() {
  showActiveBox();
}


// ---------------- RGB LED MENU ----------------
// Example: switching between 0=Off, 1=Rainbow, 2=Pulse, 3=SolidColor, etc.
int currentRGBMode = 0;

void showRGB() {
  Serial.print("RGB Mode: ");
  switch (currentRGBMode) {
    case 0: Serial.println("OFF"); break;
    case 1: Serial.println("RAINBOW"); break;
    case 2: Serial.println("PULSE"); break;
    case 3: Serial.println("SOLID COLOR"); break;
  }
}
void adjustRGB() {
  currentRGBMode = (currentRGBMode + 1) % 4;
  applyRGBMode(currentRGBMode);   // your real function
  showRGB();
}
void enterRGB() {
  showRGB();
}


// ---------------- BUZZER MENU ----------------
int buzzerPattern = 0;

void showBuzzer() {
  Serial.print("Buzzer Pattern: ");
  Serial.println(buzzerPattern);
}
void adjustBuzzer() {
  buzzerPattern = (buzzerPattern + 1) % 5;
  applyBuzzerPattern(buzzerPattern);  // your real function
  showBuzzer();
}
void enterBuzzer() {
  showBuzzer();
}

// ==================================================================
// === RGB LED CONTROL ===============================================
// ==================================================================
void setRGB(uint8_t r, uint8_t g, uint8_t b) {
  // invert because common anode LED
  analogWrite(RGB_R, 255 - r);
  analogWrite(RGB_G, 255 - g);
  analogWrite(RGB_B, 255 - b);
}

enum RGBMode {
  RGB_OFF,
  RGB_WHITE,
  RGB_RAINBOW,
  RGB_BREATHING,
  RGB_SOLID_RED,
  RGB_SOLID_GREEN,
  RGB_SOLID_BLUE,
  RGB_MODE_COUNT
};

int currentRGBMode = RGB_OFF;

void applyRGBMode() {
  switch (currentRGBMode) {

    case RGB_OFF:
      setRGB(0,0,0);
      break;

    case RGB_WHITE:
      setRGB(255,255,255);
      break;

    case RGB_SOLID_RED:
      setRGB(255,0,0);
      break;

    case RGB_SOLID_GREEN:
      setRGB(0,255,0);
      break;

    case RGB_SOLID_BLUE:
      setRGB(0,0,255);
      break;

    case RGB_RAINBOW:
      // animation handled in updateAnimations()
      break;

    case RGB_BREATHING:
      // animation handled in updateAnimations()
      break;
  }
}

unsigned long lastRGBAnimation = 0;
int rainbowPos = 0;
int breathValue = 0;
int breathDir = 1;

void updateAnimations() {
  unsigned long now = millis();

  // Rainbow cycle every 20 ms
  if (currentRGBMode == RGB_RAINBOW && now - lastRGBAnimation > 20) {
    lastRGBAnimation = now;

    // simple rainbow wheel
    int r = (sin((rainbowPos + 0) * 0.05) * 127) + 128;
    int g = (sin((rainbowPos + 2) * 0.05) * 127) + 128;
    int b = (sin((rainbowPos + 4) * 0.05) * 127) + 128;
    setRGB(r,g,b);

    rainbowPos++;
  }

  // Breathing mode every 15 ms
  if (currentRGBMode == RGB_BREATHING && now - lastRGBAnimation > 15) {
    lastRGBAnimation = now;

    breathValue += breathDir;
    if (breathValue >= 255) breathDir = -1;
    if (breathValue <= 0) breathDir = 1;

    setRGB(breathValue, breathValue, breathValue);
  }
}



// ==================================================================
// === BUZZER CONTROL ===============================================
// ==================================================================
bool buzzerLoopAlarm = false;
unsigned long buzzerLast = 0;
bool buzzerState = false;

void stopBuzzer() {
  buzzerLoopAlarm = false;
  noTone(BUZZER_PIN);
}

// Simple beep
void playBeep(int freq, int duration) {
  tone(BUZZER_PIN, freq, duration);
}

// Sequence helper
void playBeepSequence(std::initializer_list<int> freqs, int duration) {
  for (int f : freqs) {
    tone(BUZZER_PIN, f, duration);
    delay(duration + 20);
  }
  noTone(BUZZER_PIN);
}

// Alarm loop helper
void updateBuzzerAlarm() {
  unsigned long now = millis();
  if (!buzzerLoopAlarm) return;

  if (now - buzzerLast > 250) {
    buzzerLast = now;
    buzzerState = !buzzerState;

    if (buzzerState)
      tone(BUZZER_PIN, 1000);
    else
      noTone(BUZZER_PIN);
  }
}

// Morse SOS
void startMorseSOS() {
  // S (●●●)
  playBeep(800, 150); delay(150);
  playBeep(800, 150); delay(150);
  playBeep(800, 150); delay(200);

  // O (−−−)
  playBeep(800, 400); delay(200);
  playBeep(800, 400); delay(200);
  playBeep(800, 400); delay(200);

  // S (●●●)
  playBeep(800, 150); delay(150);
  playBeep(800, 150); delay(150);
  playBeep(800, 150);
}

// Apply pattern
void applyBuzzerPattern(int pattern) {
  stopBuzzer();

  switch (pattern) {
    case 0: // OFF
      break;

    case 1: // Single beep
      playBeep(1000, 120);
      break;

    case 2: // Up-down chirp
      playBeepSequence({800, 1200, 800}, 120);
      break;

    case 3: // Looping alarm pattern
      buzzerLoopAlarm = true;
      buzzerLast = millis();
      break;

    case 4: // SOS
      startMorseSOS();
      break;
  }
}



// ==================================================================
// === MOTOR CONTROL HANDLER ========================================
// ==================================================================
void handleMotorControl() {
  bool switchState = digitalRead(SWITCH_PIN);
  bool buttonState = digitalRead(LIMIT_PIN); // same physical button or another?

  bool stateChanged = false;

  if (switchState != switch_forward) {
    Serial.print("Switch changed to: ");
    Serial.println(switchState == HIGH ? "FORWARD" : "REVERSE");
    switch_forward = switchState;
    stateChanged = true;
  }

  if (buttonState != button_pressed) {
    Serial.print("Button changed to: ");
    Serial.println(buttonState == LOW ? "PRESSED" : "RELEASED");
    button_pressed = buttonState;
    stateChanged = true;
  }

  if (stateChanged) {
    modifyMotorState(switchState, buttonState);
  }
}

// ==================================================================
// === MOTOR BEHAVIOR ===============================================
// ==================================================================
void modifyMotorState(bool switchState, bool buttonState) {
  if (switchState == HIGH) {
    motor_forward = true;
    // Forward direction — button ignored
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    analogWrite(EN1, (motor_enabled ? 255 : 0));

  } else {
    motor_forward = false;
    // Reverse direction — check button
    if (buttonState == HIGH) {
      // Stop motor in reverse
      digitalWrite(IN1, LOW);
      digitalWrite(IN2, LOW);
      analogWrite(EN1, (motor_enabled ? 255 : 0));
    } else {
      // Reverse normally
      digitalWrite(IN1, LOW);
      digitalWrite(IN2, HIGH);
      analogWrite(EN1, (motor_enabled ? 255 : 0));
    }
  }
}


// ==================================================================
// === BOARD LED CONTROL ============================================
// ==================================================================
void adjustLED() {
  if (led_on) {
    analogWrite(LED_RED, 255-255*led_brightness_percentage/100);
    analogWrite(LED_GREEN, 255-255*led_brightness_percentage/100);
    analogWrite(LED_BLUE, 255-255*led_brightness_percentage/100);
  } else {
    analogWrite(LED_RED,  255-0);
    analogWrite(LED_GREEN, 255-0);
    analogWrite(LED_BLUE, 255-0);
  }
}


// ==================================================================
// === ACTIVE BOX SETTER ============================================
// ==================================================================
void setActiveBox(String box) {
  active_box = box;
  onActiveBoxChange();
}

/*
  Since ActiveBox is READ_WRITE variable, onActiveBoxChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onActiveBoxChange()  {
  Serial.print("Active Box Changed to: ");
  Serial.println(active_box);
  // Add your code here to act upon ActiveBox change
  if (active_box == BOX_NAME) {
    Serial.println("Lighting LED");
    led_on = true;
    adjustLED();
  } else {
    Serial.println("LED OFF");
    led_on = false;
    adjustLED();
  }
}